Diamonds for Orbs
Andrew Swistak
Kylie Jo Infield
Kenneth Brown
Josh Jenkins

Our team, Team Cerberus+1, implemented a set of services that are analogous to a microtransaction system. To do this, we wrote our services to interface with the popular computer game Minecraft. Although microtransactions are not a new or unique idea, we decided to this for our project because of the interesting application. 

To implement our service, we chose to program it entirely in Ruby because of its popularity among web based services, ease of use, and power of the Ruby language. The services run on a remote linux server located in Chicago that is owned by Kylie. We had no IDE commonly used among the group members, but Andrew wrote in Vim, Kylie and Kenneth wrote in Sublime Text, and Josh wrote in Eclipse. Kylie's server already hosted a Minecraft server as well as an nginx powered website (at http://orthrus.kyliejo.com/), so picking it as our target platform happened naturally. A Minecraft server jar file is available for free at http://www.minecraft.net/download; however, to log on to Minecraft, an account must be made and the game must be purchased from Mojang.

The first part of the Minecraft microtransaction service consists of an item selection service. In this service, a user submits their username as well as the item and the amount they want. The input has three arguments. Two of the formal arguments are strings (the username and item) while the other is an integer, which is used for the amount. This service take the item string and finds the corresponding item ID within the game (these IDs are determined by the developers of Minecraft, not our team). The service then returns false back to its caller if there is a problem -- such as if the item they want is not valid or if the next service returns a false value to this service. Once the item is found, it returns the itemâ€™s ID number (similar to a serial number). The last thing it will do is calculate the cost of the transaction. It bases the price off of a stack (sixty-four of one type of item is a "stack" of that item). If the user wants less or more, the price will be calculated for the amount they want. Once this finishes, this service sends username, item ID, amount, and cost to the next service.

The next service we implemented was an experience checking service. This is based on the principles of a credit check. If the user has enough levels, the transaction will complete. However, if the user does not have enough levels, this service returns false to signify it has not completed the transaction. The service receives information from its calling service, but it only needs the username and cost to determine if the user has good credit. The levels or experience the player has is retrieved from a named binary tag (NBT) file. That file contains the all the data for the player for a given server. In order to obtain the players level, we had to decompress and read the player.dat file and parse the hexadecimal representation, searching for a specific sequence of bytes that denotes the user's experience level. If it succeeds, a command is issued to the running Minecraft server to take levels from the player equal to the cost. Afterwards, the username, item ID, and amount are sent to the next service.

The last service we implemented was a distribution service. Just like the previous services, it takes in the input from a calling service. It uses the arguments it is given and inserts it into a pre-built BASH command stored as a string. Using the pre-built string, it executes the command to the server using Ruby's ability to issue Linux system commands. The command gives the user the items in-game.

The GUI we wrote has many flaws. Mainly, our workflow is linear and statically bound, so the necessity of a GUI to build a DAG-structured business process was unnecessary for the purposes of our system. Because of this, the GUI does not build a workflow based off of the drag-and-dropped elements. Rather, it checks to make sure at least one element has been dropped by the user and simply asks for input if this condition is met. The input is sent off to our first service and a result, true or false, is displayed to indicate success or failure.

